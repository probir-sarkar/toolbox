{"version":3,"sources":["../src/image-converter.ts","../src/zip.ts"],"sourcesContent":["export type ImageFormat = \"jpeg\" | \"png\" | \"webp\";\r\n\r\nexport interface ConvertOptions {\r\n  quality?: number; // 0â€“1 (jpeg/webp)\r\n}\r\n\r\nexport class ImageConverter {\r\n  private bitmap: ImageBitmap | null;\r\n\r\n  private constructor(bitmap: ImageBitmap) {\r\n    this.bitmap = bitmap;\r\n  }\r\n\r\n  static async fromBlob(blob: Blob): Promise<ImageConverter> {\r\n    const bitmap = await createImageBitmap(blob);\r\n    return new ImageConverter(bitmap);\r\n  }\r\n\r\n  async convert(format: ImageFormat, options?: ConvertOptions): Promise<Uint8Array> {\r\n    if (!this.bitmap) {\r\n      throw new Error(\"ImageConverter already destroyed\");\r\n    }\r\n\r\n    const canvas = document.createElement(\"canvas\");\r\n    canvas.width = this.bitmap.width;\r\n    canvas.height = this.bitmap.height;\r\n\r\n    const ctx = canvas.getContext(\"2d\");\r\n    if (!ctx) throw new Error(\"Canvas not supported\");\r\n\r\n    ctx.drawImage(this.bitmap, 0, 0);\r\n\r\n    const mime = format === \"jpeg\" ? \"image/jpeg\" : format === \"webp\" ? \"image/webp\" : \"image/png\";\r\n\r\n    const blob = await new Promise<Blob>((resolve) => canvas.toBlob((b) => resolve(b!), mime, options?.quality));\r\n\r\n    return new Uint8Array(await blob.arrayBuffer());\r\n  }\r\n\r\n  destroy(): void {\r\n    this.bitmap?.close();\r\n    this.bitmap = null;\r\n  }\r\n}\r\n","import JSZip from \"jszip\";\n\n/**\n * Represents a file to be added to a ZIP archive\n */\nexport interface ZipFileEntry {\n  /**\n   * The name/path of the file in the archive\n   */\n  name: string;\n\n  /**\n   * The file content as a Blob\n   */\n  content: Blob;\n}\n\n/**\n * Options for creating a ZIP archive\n */\nexport interface ZipOptions {\n  /**\n   * The name of the ZIP file (without .zip extension)\n   * @default \"archive\"\n   */\n  filename?: string;\n\n  /**\n   * Compression level (0-9)\n   * @default 6\n   */\n  compressionLevel?: number;\n\n  /**\n   * Optional progress callback\n   */\n  onProgress?: (percent: number) => void;\n}\n\n/**\n * Creates a ZIP file from an array of file entries\n *\n * @param files - Array of file entries to include in the archive\n * @param options - Optional configuration for the ZIP creation\n * @returns Promise resolving to a Blob containing the ZIP data\n *\n * @example\n * ```ts\n * const files: ZipFileEntry[] = [\n *   { name: \"image1.jpg\", content: blob1 },\n *   { name: \"image2.jpg\", content: blob2 }\n * ];\n *\n * const zipBlob = await createZip(files, {\n *   filename: \"converted-images\",\n *   compressionLevel: 6\n * });\n * ```\n */\nexport async function createZip(\n  files: ZipFileEntry[],\n  options: ZipOptions = {}\n): Promise<Blob> {\n  const {\n    filename = \"archive\",\n    compressionLevel = 6,\n    onProgress\n  } = options;\n\n  const zip = new JSZip();\n  const totalFiles = files.length;\n\n  // Add all files to the ZIP\n  for (let i = 0; i < totalFiles; i++) {\n    const file = files[i];\n    zip.file(file.name, file.content, { compression: \"DEFLATE\", compressionOptions: { level: compressionLevel } });\n\n    // Report progress (0-50% for adding files, 50-100% for generation)\n    onProgress?.(Math.round((i / totalFiles) * 50));\n  }\n\n  // Generate the ZIP file\n  onProgress?.(50);\n  const zipBlob = await zip.generateAsync({\n    type: \"blob\",\n    compression: \"DEFLATE\",\n    compressionOptions: { level: compressionLevel }\n  }, (metadata) => {\n    // metadata.percent goes from 0 to 100 during generation\n    // We want to map this to 50-100% of total progress\n    const totalProgress = 50 + Math.round(metadata.percent / 2);\n    onProgress?.(totalProgress);\n  });\n\n  onProgress?.(100);\n  return zipBlob;\n}\n\n/**\n * Triggers a download of a ZIP file in the browser\n *\n * @param zipBlob - The ZIP file blob to download\n * @param filename - The name for the downloaded file (with or without .zip extension)\n *\n * @example\n * ```ts\n * const zipBlob = await createZip(files);\n * downloadZip(zipBlob, \"my-files\");\n * // Downloads as \"my-files.zip\"\n * ```\n */\nexport function downloadZip(zipBlob: Blob, filename: string): void {\n  const url = URL.createObjectURL(zipBlob);\n  const a = document.createElement(\"a\");\n\n  // Ensure .zip extension\n  const finalFilename = filename.endsWith(\".zip\") ? filename : `${filename}.zip`;\n\n  a.href = url;\n  a.download = finalFilename;\n  document.body.appendChild(a);\n  a.click();\n  document.body.removeChild(a);\n  URL.revokeObjectURL(url);\n}\n\n/**\n * Creates and downloads a ZIP file in a single operation\n *\n * @param files - Array of file entries to include in the archive\n * @param options - Optional configuration for the ZIP creation\n * @returns Promise that resolves when the download has been triggered\n *\n * @example\n * ```ts\n * await createAndDownloadZip(files, {\n *   filename: \"converted-images\"\n * });\n * ```\n */\nexport async function createAndDownloadZip(\n  files: ZipFileEntry[],\n  options: ZipOptions = {}\n): Promise<void> {\n  const zipBlob = await createZip(files, options);\n  downloadZip(zipBlob, options.filename || \"archive\");\n}\n\n/**\n * Converts File objects to ZipFileEntry format\n * Useful when working with file inputs or File objects\n *\n * @param files - Array of File objects\n * @returns Array of ZipFileEntry objects\n *\n * @example\n * ```ts\n * const fileInput = document.querySelector(\"input[type='file']\");\n * const files = Array.from(fileInput.files);\n * const entries = filesToZipEntries(files);\n * await createAndDownloadZip(entries);\n * ```\n */\nexport function filesToZipEntries(files: File[]): ZipFileEntry[] {\n  return files.map((file) => ({\n    name: file.name,\n    content: file\n  }));\n}\n\n/**\n * Creates a ZIP from File objects directly\n * Convenience function that combines filesToZipEntries and createZip\n *\n * @param files - Array of File objects\n * @param options - Optional configuration for the ZIP creation\n * @returns Promise resolving to a Blob containing the ZIP data\n */\nexport async function createZipFromFiles(\n  files: File[],\n  options: ZipOptions = {}\n): Promise<Blob> {\n  const entries = filesToZipEntries(files);\n  return createZip(entries, options);\n}\n"],"mappings":";AAMO,IAAM,iBAAN,MAAM,gBAAe;AAAA,EAGlB,YAAY,QAAqB;AACvC,SAAK,SAAS;AAAA,EAChB;AAAA,EAEA,aAAa,SAAS,MAAqC;AACzD,UAAM,SAAS,MAAM,kBAAkB,IAAI;AAC3C,WAAO,IAAI,gBAAe,MAAM;AAAA,EAClC;AAAA,EAEA,MAAM,QAAQ,QAAqB,SAA+C;AAChF,QAAI,CAAC,KAAK,QAAQ;AAChB,YAAM,IAAI,MAAM,kCAAkC;AAAA,IACpD;AAEA,UAAM,SAAS,SAAS,cAAc,QAAQ;AAC9C,WAAO,QAAQ,KAAK,OAAO;AAC3B,WAAO,SAAS,KAAK,OAAO;AAE5B,UAAM,MAAM,OAAO,WAAW,IAAI;AAClC,QAAI,CAAC,IAAK,OAAM,IAAI,MAAM,sBAAsB;AAEhD,QAAI,UAAU,KAAK,QAAQ,GAAG,CAAC;AAE/B,UAAM,OAAO,WAAW,SAAS,eAAe,WAAW,SAAS,eAAe;AAEnF,UAAM,OAAO,MAAM,IAAI,QAAc,CAAC,YAAY,OAAO,OAAO,CAAC,MAAM,QAAQ,CAAE,GAAG,MAAM,SAAS,OAAO,CAAC;AAE3G,WAAO,IAAI,WAAW,MAAM,KAAK,YAAY,CAAC;AAAA,EAChD;AAAA,EAEA,UAAgB;AACd,SAAK,QAAQ,MAAM;AACnB,SAAK,SAAS;AAAA,EAChB;AACF;;;AC3CA,OAAO,WAAW;AA2DlB,eAAsB,UACpB,OACA,UAAsB,CAAC,GACR;AACf,QAAM;AAAA,IACJ,WAAW;AAAA,IACX,mBAAmB;AAAA,IACnB;AAAA,EACF,IAAI;AAEJ,QAAM,MAAM,IAAI,MAAM;AACtB,QAAM,aAAa,MAAM;AAGzB,WAAS,IAAI,GAAG,IAAI,YAAY,KAAK;AACnC,UAAM,OAAO,MAAM,CAAC;AACpB,QAAI,KAAK,KAAK,MAAM,KAAK,SAAS,EAAE,aAAa,WAAW,oBAAoB,EAAE,OAAO,iBAAiB,EAAE,CAAC;AAG7G,iBAAa,KAAK,MAAO,IAAI,aAAc,EAAE,CAAC;AAAA,EAChD;AAGA,eAAa,EAAE;AACf,QAAM,UAAU,MAAM,IAAI,cAAc;AAAA,IACtC,MAAM;AAAA,IACN,aAAa;AAAA,IACb,oBAAoB,EAAE,OAAO,iBAAiB;AAAA,EAChD,GAAG,CAAC,aAAa;AAGf,UAAM,gBAAgB,KAAK,KAAK,MAAM,SAAS,UAAU,CAAC;AAC1D,iBAAa,aAAa;AAAA,EAC5B,CAAC;AAED,eAAa,GAAG;AAChB,SAAO;AACT;AAeO,SAAS,YAAY,SAAe,UAAwB;AACjE,QAAM,MAAM,IAAI,gBAAgB,OAAO;AACvC,QAAM,IAAI,SAAS,cAAc,GAAG;AAGpC,QAAM,gBAAgB,SAAS,SAAS,MAAM,IAAI,WAAW,GAAG,QAAQ;AAExE,IAAE,OAAO;AACT,IAAE,WAAW;AACb,WAAS,KAAK,YAAY,CAAC;AAC3B,IAAE,MAAM;AACR,WAAS,KAAK,YAAY,CAAC;AAC3B,MAAI,gBAAgB,GAAG;AACzB;AAgBA,eAAsB,qBACpB,OACA,UAAsB,CAAC,GACR;AACf,QAAM,UAAU,MAAM,UAAU,OAAO,OAAO;AAC9C,cAAY,SAAS,QAAQ,YAAY,SAAS;AACpD;AAiBO,SAAS,kBAAkB,OAA+B;AAC/D,SAAO,MAAM,IAAI,CAAC,UAAU;AAAA,IAC1B,MAAM,KAAK;AAAA,IACX,SAAS;AAAA,EACX,EAAE;AACJ;AAUA,eAAsB,mBACpB,OACA,UAAsB,CAAC,GACR;AACf,QAAM,UAAU,kBAAkB,KAAK;AACvC,SAAO,UAAU,SAAS,OAAO;AACnC;","names":[]}